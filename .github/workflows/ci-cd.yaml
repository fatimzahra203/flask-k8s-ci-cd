name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      # 1. R√©cup√©rer le code
      - uses: actions/checkout@v3
      
      # 2. Configurer les credentials AWS
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-3
      
      # 3. Ex√©cuter les tests unitaires
      - name: Run tests
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest
          pytest tests/ || true
      
      # 4. Se connecter √† ECR
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
        continue-on-error: true
      
      # 5. Construire l'image Docker
      - name: Build Docker image
        if: success()
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          REPOSITORY: flask-web-app
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG .
          docker tag $REGISTRY/$REPOSITORY:$IMAGE_TAG $REGISTRY/$REPOSITORY:latest
      
      # 6. Push l'image vers ECR
      - name: Push image to ECR
        if: success()
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          REPOSITORY: flask-web-app
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          docker push $REGISTRY/$REPOSITORY:latest
      
      # 7. Installer kubectl et eksctl
      - name: Install kubectl and eksctl
        if: success()
        run: |
          curl -o kubectl https://amazon-eks.s3.us-west-2.amazonaws.com/1.27.0/2023-03-17/bin/linux/amd64/kubectl
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          
          curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
          sudo mv /tmp/eksctl /usr/local/bin/
      
      # 8. Mettre √† jour le kubeconfig
      - name: Update kubeconfig
        if: success()
        run: |
          aws eks update-kubeconfig --name spring-spot-cluster --region eu-west-3
      
      # 9. Mettre √† jour le deployment.yaml avec la nouvelle image
      - name: Update deployment image
        if: success()
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          REPOSITORY: flask-web-app
          IMAGE_TAG: ${{ github.sha }}
        run: |
          sed -i "s|image:.*|image: $REGISTRY/$REPOSITORY:$IMAGE_TAG|g" deployment.yaml
      
      # 10. D√©ployer sur EKS
      - name: Deploy to EKS
        if: success()
        run: |
          kubectl apply -f deployment.yaml
          kubectl rollout status deployment/app-aws --timeout=5m
      
      # 11. V√©rifier le d√©ploiement
      - name: Verify deployment
        if: success()
        run: |
          kubectl get pods
          kubectl get svc
          
          # Attendre que le LoadBalancer obtienne une IP
          for i in {1..30}; do
            LB_IP=$(kubectl get svc app-aws -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            if [ ! -z "$LB_IP" ]; then
              echo "LoadBalancer IP: $LB_IP"
              break
            fi
            echo "En attente de l'IP du LoadBalancer... ($i/30)"
            sleep 10
          done
      
      # 12. Tests de sant√© (optionnel)
      - name: Health check
        if: success()
        continue-on-error: true
        run: |
          LB_IP=$(kubectl get svc app-aws -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          if [ ! -z "$LB_IP" ]; then
            echo "Testing: http://$LB_IP/"
            curl -f http://$LB_IP/ || echo "Application not yet responding (normal au premier d√©ploiement)"
          fi
      
      # ‚úÖ SOLUTION 1 : Cr√©er une issue au lieu de commenter (avec github-script)
      - name: Create issue on failure
        if: failure()
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üö® D√©ploiement √©chou√© - ${{ github.ref }}',
              body: `## D√©ploiement √©chou√© ‚ùå
            
            **Branch** : ${{ github.ref }}
            **Commit** : ${{ github.sha }}
            **Auteur** : ${{ github.actor }}
            **Run ID** : ${{ github.run_id }}
            
            ### üìã Actions √† prendre :
            1. Consultez les [logs du workflow](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            2. V√©rifiez les erreurs dans les √©tapes
            3. Corrigez le code et refaites un push
            
            ### üîß Commandes utiles pour d√©boguer :
            \`\`\`bash
            # V√©rifier les pods
            kubectl get pods
            
            # Voir les logs du pod
            kubectl logs <pod-name>
            
            # D√©crire le pod pour voir les erreurs
            kubectl describe pod <pod-name>
            
            # Voir le statut du d√©ploiement
            kubectl rollout status deployment/app-aws
            \`\`\`
            `,
              labels: ['bug', 'deployment', 'ci-cd-failed']
            })
      
      # ‚úÖ Alternative : Envoyer une notification Slack au lieu de GitHub
      - name: Send Slack notification
        if: always()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "D√©ploiement ${{ job.status }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*D√©ploiement ${{ job.status == 'success' && '‚úÖ Succ√®s' || '‚ùå √âchou√©' }}*\nBranch: ${{ github.ref }}\nCommit: ${{ github.sha }}\nAuteur: ${{ github.actor }}"
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "Voir les logs"
                      },
                      "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
        continue-on-error: true

      # ‚úÖ Debug : Afficher les informations du contexte
      - name: Debug context
        if: always()
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Actor: ${{ github.actor }}"
          echo "Run ID: ${{ github.run_id }}"